module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Account {
  id: ID!
  bank: String!
  accountNum: String!
  owner: String!
}

type AccountConnection {
  pageInfo: PageInfo!
  edges: [AccountEdge]!
  aggregate: AggregateAccount!
}

input AccountCreateInput {
  id: ID
  bank: String!
  accountNum: String!
  owner: String!
}

input AccountCreateOneInput {
  create: AccountCreateInput
  connect: AccountWhereUniqueInput
}

type AccountEdge {
  node: Account!
  cursor: String!
}

enum AccountOrderByInput {
  id_ASC
  id_DESC
  bank_ASC
  bank_DESC
  accountNum_ASC
  accountNum_DESC
  owner_ASC
  owner_DESC
}

type AccountPreviousValues {
  id: ID!
  bank: String!
  accountNum: String!
  owner: String!
}

type AccountSubscriptionPayload {
  mutation: MutationType!
  node: Account
  updatedFields: [String!]
  previousValues: AccountPreviousValues
}

input AccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AccountWhereInput
  AND: [AccountSubscriptionWhereInput!]
  OR: [AccountSubscriptionWhereInput!]
  NOT: [AccountSubscriptionWhereInput!]
}

input AccountUpdateDataInput {
  bank: String
  accountNum: String
  owner: String
}

input AccountUpdateInput {
  bank: String
  accountNum: String
  owner: String
}

input AccountUpdateManyMutationInput {
  bank: String
  accountNum: String
  owner: String
}

input AccountUpdateOneRequiredInput {
  create: AccountCreateInput
  update: AccountUpdateDataInput
  upsert: AccountUpsertNestedInput
  connect: AccountWhereUniqueInput
}

input AccountUpsertNestedInput {
  update: AccountUpdateDataInput!
  create: AccountCreateInput!
}

input AccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  bank: String
  bank_not: String
  bank_in: [String!]
  bank_not_in: [String!]
  bank_lt: String
  bank_lte: String
  bank_gt: String
  bank_gte: String
  bank_contains: String
  bank_not_contains: String
  bank_starts_with: String
  bank_not_starts_with: String
  bank_ends_with: String
  bank_not_ends_with: String
  accountNum: String
  accountNum_not: String
  accountNum_in: [String!]
  accountNum_not_in: [String!]
  accountNum_lt: String
  accountNum_lte: String
  accountNum_gt: String
  accountNum_gte: String
  accountNum_contains: String
  accountNum_not_contains: String
  accountNum_starts_with: String
  accountNum_not_starts_with: String
  accountNum_ends_with: String
  accountNum_not_ends_with: String
  owner: String
  owner_not: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_gt: String
  owner_gte: String
  owner_contains: String
  owner_not_contains: String
  owner_starts_with: String
  owner_not_starts_with: String
  owner_ends_with: String
  owner_not_ends_with: String
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
}

input AccountWhereUniqueInput {
  id: ID
}

type AggregateAccount {
  count: Int!
}

type AggregateBlockedUser {
  count: Int!
}

type AggregateChatRoom {
  count: Int!
}

type AggregateDeactivate {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMessage {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateReport {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type BlockedUser {
  id: ID!
  block: User!
  deactivateDate: DateTime!
}

type BlockedUserConnection {
  pageInfo: PageInfo!
  edges: [BlockedUserEdge]!
  aggregate: AggregateBlockedUser!
}

input BlockedUserCreateInput {
  id: ID
  block: UserCreateOneInput!
  deactivateDate: DateTime!
}

type BlockedUserEdge {
  node: BlockedUser!
  cursor: String!
}

enum BlockedUserOrderByInput {
  id_ASC
  id_DESC
  deactivateDate_ASC
  deactivateDate_DESC
}

type BlockedUserPreviousValues {
  id: ID!
  deactivateDate: DateTime!
}

type BlockedUserSubscriptionPayload {
  mutation: MutationType!
  node: BlockedUser
  updatedFields: [String!]
  previousValues: BlockedUserPreviousValues
}

input BlockedUserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BlockedUserWhereInput
  AND: [BlockedUserSubscriptionWhereInput!]
  OR: [BlockedUserSubscriptionWhereInput!]
  NOT: [BlockedUserSubscriptionWhereInput!]
}

input BlockedUserUpdateInput {
  block: UserUpdateOneRequiredInput
  deactivateDate: DateTime
}

input BlockedUserUpdateManyMutationInput {
  deactivateDate: DateTime
}

input BlockedUserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  block: UserWhereInput
  deactivateDate: DateTime
  deactivateDate_not: DateTime
  deactivateDate_in: [DateTime!]
  deactivateDate_not_in: [DateTime!]
  deactivateDate_lt: DateTime
  deactivateDate_lte: DateTime
  deactivateDate_gt: DateTime
  deactivateDate_gte: DateTime
  AND: [BlockedUserWhereInput!]
  OR: [BlockedUserWhereInput!]
  NOT: [BlockedUserWhereInput!]
}

input BlockedUserWhereUniqueInput {
  id: ID
}

type ChatRoom {
  id: ID!
  title: String!
  Users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message!]
}

type ChatRoomConnection {
  pageInfo: PageInfo!
  edges: [ChatRoomEdge]!
  aggregate: AggregateChatRoom!
}

input ChatRoomCreateInput {
  id: ID
  title: String!
  Users: UserCreateManyInput
  messages: MessageCreateManyInput
}

input ChatRoomCreateOneInput {
  create: ChatRoomCreateInput
  connect: ChatRoomWhereUniqueInput
}

type ChatRoomEdge {
  node: ChatRoom!
  cursor: String!
}

enum ChatRoomOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
}

type ChatRoomPreviousValues {
  id: ID!
  title: String!
}

type ChatRoomSubscriptionPayload {
  mutation: MutationType!
  node: ChatRoom
  updatedFields: [String!]
  previousValues: ChatRoomPreviousValues
}

input ChatRoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatRoomWhereInput
  AND: [ChatRoomSubscriptionWhereInput!]
  OR: [ChatRoomSubscriptionWhereInput!]
  NOT: [ChatRoomSubscriptionWhereInput!]
}

input ChatRoomUpdateDataInput {
  title: String
  Users: UserUpdateManyInput
  messages: MessageUpdateManyInput
}

input ChatRoomUpdateInput {
  title: String
  Users: UserUpdateManyInput
  messages: MessageUpdateManyInput
}

input ChatRoomUpdateManyMutationInput {
  title: String
}

input ChatRoomUpdateOneRequiredInput {
  create: ChatRoomCreateInput
  update: ChatRoomUpdateDataInput
  upsert: ChatRoomUpsertNestedInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomUpsertNestedInput {
  update: ChatRoomUpdateDataInput!
  create: ChatRoomCreateInput!
}

input ChatRoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  Users_every: UserWhereInput
  Users_some: UserWhereInput
  Users_none: UserWhereInput
  messages_every: MessageWhereInput
  messages_some: MessageWhereInput
  messages_none: MessageWhereInput
  AND: [ChatRoomWhereInput!]
  OR: [ChatRoomWhereInput!]
  NOT: [ChatRoomWhereInput!]
}

input ChatRoomWhereUniqueInput {
  id: ID
}

scalar DateTime

type Deactivate {
  id: ID!
  deactivateUser: User!
  why: Int!
  deactivateReason: String
  deactivatedDate: DateTime!
}

type DeactivateConnection {
  pageInfo: PageInfo!
  edges: [DeactivateEdge]!
  aggregate: AggregateDeactivate!
}

input DeactivateCreateInput {
  id: ID
  deactivateUser: UserCreateOneInput!
  why: Int!
  deactivateReason: String
  deactivatedDate: DateTime!
}

type DeactivateEdge {
  node: Deactivate!
  cursor: String!
}

enum DeactivateOrderByInput {
  id_ASC
  id_DESC
  why_ASC
  why_DESC
  deactivateReason_ASC
  deactivateReason_DESC
  deactivatedDate_ASC
  deactivatedDate_DESC
}

type DeactivatePreviousValues {
  id: ID!
  why: Int!
  deactivateReason: String
  deactivatedDate: DateTime!
}

type DeactivateSubscriptionPayload {
  mutation: MutationType!
  node: Deactivate
  updatedFields: [String!]
  previousValues: DeactivatePreviousValues
}

input DeactivateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DeactivateWhereInput
  AND: [DeactivateSubscriptionWhereInput!]
  OR: [DeactivateSubscriptionWhereInput!]
  NOT: [DeactivateSubscriptionWhereInput!]
}

input DeactivateUpdateInput {
  deactivateUser: UserUpdateOneRequiredInput
  why: Int
  deactivateReason: String
  deactivatedDate: DateTime
}

input DeactivateUpdateManyMutationInput {
  why: Int
  deactivateReason: String
  deactivatedDate: DateTime
}

input DeactivateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  deactivateUser: UserWhereInput
  why: Int
  why_not: Int
  why_in: [Int!]
  why_not_in: [Int!]
  why_lt: Int
  why_lte: Int
  why_gt: Int
  why_gte: Int
  deactivateReason: String
  deactivateReason_not: String
  deactivateReason_in: [String!]
  deactivateReason_not_in: [String!]
  deactivateReason_lt: String
  deactivateReason_lte: String
  deactivateReason_gt: String
  deactivateReason_gte: String
  deactivateReason_contains: String
  deactivateReason_not_contains: String
  deactivateReason_starts_with: String
  deactivateReason_not_starts_with: String
  deactivateReason_ends_with: String
  deactivateReason_not_ends_with: String
  deactivatedDate: DateTime
  deactivatedDate_not: DateTime
  deactivatedDate_in: [DateTime!]
  deactivatedDate_not_in: [DateTime!]
  deactivatedDate_lt: DateTime
  deactivatedDate_lte: DateTime
  deactivatedDate_gt: DateTime
  deactivatedDate_gte: DateTime
  AND: [DeactivateWhereInput!]
  OR: [DeactivateWhereInput!]
  NOT: [DeactivateWhereInput!]
}

input DeactivateWhereUniqueInput {
  id: ID
}

type File {
  id: ID!
  url: String!
}

type FileConnection {
  pageInfo: PageInfo!
  edges: [FileEdge]!
  aggregate: AggregateFile!
}

input FileCreateInput {
  id: ID
  url: String!
}

input FileCreateOneInput {
  create: FileCreateInput
  connect: FileWhereUniqueInput
}

type FileEdge {
  node: File!
  cursor: String!
}

enum FileOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
}

type FilePreviousValues {
  id: ID!
  url: String!
}

type FileSubscriptionPayload {
  mutation: MutationType!
  node: File
  updatedFields: [String!]
  previousValues: FilePreviousValues
}

input FileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FileWhereInput
  AND: [FileSubscriptionWhereInput!]
  OR: [FileSubscriptionWhereInput!]
  NOT: [FileSubscriptionWhereInput!]
}

input FileUpdateDataInput {
  url: String
}

input FileUpdateInput {
  url: String
}

input FileUpdateManyMutationInput {
  url: String
}

input FileUpdateOneInput {
  create: FileCreateInput
  update: FileUpdateDataInput
  upsert: FileUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: FileWhereUniqueInput
}

input FileUpsertNestedInput {
  update: FileUpdateDataInput!
  create: FileCreateInput!
}

input FileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
}

input FileWhereUniqueInput {
  id: ID
}

type Location {
  id: ID!
  name: String!
  Latitude: Float!
  Longitude: Float!
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  name: String!
  Latitude: Float!
  Longitude: Float!
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  Latitude_ASC
  Latitude_DESC
  Longitude_ASC
  Longitude_DESC
}

type LocationPreviousValues {
  id: ID!
  name: String!
  Latitude: Float!
  Longitude: Float!
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

input LocationUpdateDataInput {
  name: String
  Latitude: Float
  Longitude: Float
}

input LocationUpdateInput {
  name: String
  Latitude: Float
  Longitude: Float
}

input LocationUpdateManyMutationInput {
  name: String
  Latitude: Float
  Longitude: Float
}

input LocationUpdateOneRequiredInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  connect: LocationWhereUniqueInput
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  Latitude: Float
  Latitude_not: Float
  Latitude_in: [Float!]
  Latitude_not_in: [Float!]
  Latitude_lt: Float
  Latitude_lte: Float
  Latitude_gt: Float
  Latitude_gte: Float
  Longitude: Float
  Longitude_not: Float
  Longitude_in: [Float!]
  Longitude_not_in: [Float!]
  Longitude_lt: Float
  Longitude_lte: Float
  Longitude_gt: Float
  Longitude_gte: Float
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Message {
  id: ID!
  from: User!
  content: String!
  createDate: DateTime!
}

type MessageConnection {
  pageInfo: PageInfo!
  edges: [MessageEdge]!
  aggregate: AggregateMessage!
}

input MessageCreateInput {
  id: ID
  from: UserCreateOneInput!
  content: String!
  createDate: DateTime!
}

input MessageCreateManyInput {
  create: [MessageCreateInput!]
  connect: [MessageWhereUniqueInput!]
}

type MessageEdge {
  node: Message!
  cursor: String!
}

enum MessageOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  createDate_ASC
  createDate_DESC
}

type MessagePreviousValues {
  id: ID!
  content: String!
  createDate: DateTime!
}

input MessageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createDate: DateTime
  createDate_not: DateTime
  createDate_in: [DateTime!]
  createDate_not_in: [DateTime!]
  createDate_lt: DateTime
  createDate_lte: DateTime
  createDate_gt: DateTime
  createDate_gte: DateTime
  AND: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
  NOT: [MessageScalarWhereInput!]
}

type MessageSubscriptionPayload {
  mutation: MutationType!
  node: Message
  updatedFields: [String!]
  previousValues: MessagePreviousValues
}

input MessageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MessageWhereInput
  AND: [MessageSubscriptionWhereInput!]
  OR: [MessageSubscriptionWhereInput!]
  NOT: [MessageSubscriptionWhereInput!]
}

input MessageUpdateDataInput {
  from: UserUpdateOneRequiredInput
  content: String
  createDate: DateTime
}

input MessageUpdateInput {
  from: UserUpdateOneRequiredInput
  content: String
  createDate: DateTime
}

input MessageUpdateManyDataInput {
  content: String
  createDate: DateTime
}

input MessageUpdateManyInput {
  create: [MessageCreateInput!]
  update: [MessageUpdateWithWhereUniqueNestedInput!]
  upsert: [MessageUpsertWithWhereUniqueNestedInput!]
  delete: [MessageWhereUniqueInput!]
  connect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  disconnect: [MessageWhereUniqueInput!]
  deleteMany: [MessageScalarWhereInput!]
  updateMany: [MessageUpdateManyWithWhereNestedInput!]
}

input MessageUpdateManyMutationInput {
  content: String
  createDate: DateTime
}

input MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput!
  data: MessageUpdateManyDataInput!
}

input MessageUpdateWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput!
  data: MessageUpdateDataInput!
}

input MessageUpsertWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput!
  update: MessageUpdateDataInput!
  create: MessageCreateInput!
}

input MessageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  from: UserWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createDate: DateTime
  createDate_not: DateTime
  createDate_in: [DateTime!]
  createDate_not_in: [DateTime!]
  createDate_lt: DateTime
  createDate_lte: DateTime
  createDate_gt: DateTime
  createDate_gte: DateTime
  AND: [MessageWhereInput!]
  OR: [MessageWhereInput!]
  NOT: [MessageWhereInput!]
}

input MessageWhereUniqueInput {
  id: ID
}

type Mutation {
  createAccount(data: AccountCreateInput!): Account!
  updateAccount(data: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account
  updateManyAccounts(data: AccountUpdateManyMutationInput!, where: AccountWhereInput): BatchPayload!
  upsertAccount(where: AccountWhereUniqueInput!, create: AccountCreateInput!, update: AccountUpdateInput!): Account!
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteManyAccounts(where: AccountWhereInput): BatchPayload!
  createBlockedUser(data: BlockedUserCreateInput!): BlockedUser!
  updateBlockedUser(data: BlockedUserUpdateInput!, where: BlockedUserWhereUniqueInput!): BlockedUser
  updateManyBlockedUsers(data: BlockedUserUpdateManyMutationInput!, where: BlockedUserWhereInput): BatchPayload!
  upsertBlockedUser(where: BlockedUserWhereUniqueInput!, create: BlockedUserCreateInput!, update: BlockedUserUpdateInput!): BlockedUser!
  deleteBlockedUser(where: BlockedUserWhereUniqueInput!): BlockedUser
  deleteManyBlockedUsers(where: BlockedUserWhereInput): BatchPayload!
  createChatRoom(data: ChatRoomCreateInput!): ChatRoom!
  updateChatRoom(data: ChatRoomUpdateInput!, where: ChatRoomWhereUniqueInput!): ChatRoom
  updateManyChatRooms(data: ChatRoomUpdateManyMutationInput!, where: ChatRoomWhereInput): BatchPayload!
  upsertChatRoom(where: ChatRoomWhereUniqueInput!, create: ChatRoomCreateInput!, update: ChatRoomUpdateInput!): ChatRoom!
  deleteChatRoom(where: ChatRoomWhereUniqueInput!): ChatRoom
  deleteManyChatRooms(where: ChatRoomWhereInput): BatchPayload!
  createDeactivate(data: DeactivateCreateInput!): Deactivate!
  updateDeactivate(data: DeactivateUpdateInput!, where: DeactivateWhereUniqueInput!): Deactivate
  updateManyDeactivates(data: DeactivateUpdateManyMutationInput!, where: DeactivateWhereInput): BatchPayload!
  upsertDeactivate(where: DeactivateWhereUniqueInput!, create: DeactivateCreateInput!, update: DeactivateUpdateInput!): Deactivate!
  deleteDeactivate(where: DeactivateWhereUniqueInput!): Deactivate
  deleteManyDeactivates(where: DeactivateWhereInput): BatchPayload!
  createFile(data: FileCreateInput!): File!
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  upsertFile(where: FileWhereUniqueInput!, create: FileCreateInput!, update: FileUpdateInput!): File!
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createMessage(data: MessageCreateInput!): Message!
  updateMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
  updateManyMessages(data: MessageUpdateManyMutationInput!, where: MessageWhereInput): BatchPayload!
  upsertMessage(where: MessageWhereUniqueInput!, create: MessageCreateInput!, update: MessageUpdateInput!): Message!
  deleteMessage(where: MessageWhereUniqueInput!): Message
  deleteManyMessages(where: MessageWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createReport(data: ReportCreateInput!): Report!
  updateReport(data: ReportUpdateInput!, where: ReportWhereUniqueInput!): Report
  updateManyReports(data: ReportUpdateManyMutationInput!, where: ReportWhereInput): BatchPayload!
  upsertReport(where: ReportWhereUniqueInput!, create: ReportCreateInput!, update: ReportUpdateInput!): Report!
  deleteReport(where: ReportWhereUniqueInput!): Report
  deleteManyReports(where: ReportWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  unpaidUser(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  price: Int
  connectedRoom: Room!
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  unpaidUser: UserCreateManyInput
  price: Int
  connectedRoom: RoomCreateOneWithoutPayInput!
}

input PaymentCreateOneWithoutConnectedRoomInput {
  create: PaymentCreateWithoutConnectedRoomInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutConnectedRoomInput {
  id: ID
  unpaidUser: UserCreateManyInput
  price: Int
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  price_ASC
  price_DESC
}

type PaymentPreviousValues {
  id: ID!
  price: Int
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  unpaidUser: UserUpdateManyInput
  price: Int
  connectedRoom: RoomUpdateOneRequiredWithoutPayInput
}

input PaymentUpdateManyMutationInput {
  price: Int
}

input PaymentUpdateOneWithoutConnectedRoomInput {
  create: PaymentCreateWithoutConnectedRoomInput
  update: PaymentUpdateWithoutConnectedRoomDataInput
  upsert: PaymentUpsertWithoutConnectedRoomInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutConnectedRoomDataInput {
  unpaidUser: UserUpdateManyInput
  price: Int
}

input PaymentUpsertWithoutConnectedRoomInput {
  update: PaymentUpdateWithoutConnectedRoomDataInput!
  create: PaymentCreateWithoutConnectedRoomInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  unpaidUser_every: UserWhereInput
  unpaidUser_some: UserWhereInput
  unpaidUser_none: UserWhereInput
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  connectedRoom: RoomWhereInput
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Query {
  account(where: AccountWhereUniqueInput!): Account
  accounts(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Account]!
  accountsConnection(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AccountConnection!
  blockedUser(where: BlockedUserWhereUniqueInput!): BlockedUser
  blockedUsers(where: BlockedUserWhereInput, orderBy: BlockedUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BlockedUser]!
  blockedUsersConnection(where: BlockedUserWhereInput, orderBy: BlockedUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BlockedUserConnection!
  chatRoom(where: ChatRoomWhereUniqueInput!): ChatRoom
  chatRooms(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatRoom]!
  chatRoomsConnection(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatRoomConnection!
  deactivate(where: DeactivateWhereUniqueInput!): Deactivate
  deactivates(where: DeactivateWhereInput, orderBy: DeactivateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Deactivate]!
  deactivatesConnection(where: DeactivateWhereInput, orderBy: DeactivateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DeactivateConnection!
  file(where: FileWhereUniqueInput!): File
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File]!
  filesConnection(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FileConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  message(where: MessageWhereUniqueInput!): Message
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message]!
  messagesConnection(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MessageConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  report(where: ReportWhereUniqueInput!): Report
  reports(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report]!
  reportsConnection(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReportConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Report {
  id: ID!
  reportedUser: User!
  from: User!
  reason: String!
  where: Room!
  state: String!
}

type ReportConnection {
  pageInfo: PageInfo!
  edges: [ReportEdge]!
  aggregate: AggregateReport!
}

input ReportCreateInput {
  id: ID
  reportedUser: UserCreateOneInput!
  from: UserCreateOneInput!
  reason: String!
  where: RoomCreateOneInput!
  state: String!
}

input ReportCreateManyInput {
  create: [ReportCreateInput!]
  connect: [ReportWhereUniqueInput!]
}

type ReportEdge {
  node: Report!
  cursor: String!
}

enum ReportOrderByInput {
  id_ASC
  id_DESC
  reason_ASC
  reason_DESC
  state_ASC
  state_DESC
}

type ReportPreviousValues {
  id: ID!
  reason: String!
  state: String!
}

input ReportScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reason: String
  reason_not: String
  reason_in: [String!]
  reason_not_in: [String!]
  reason_lt: String
  reason_lte: String
  reason_gt: String
  reason_gte: String
  reason_contains: String
  reason_not_contains: String
  reason_starts_with: String
  reason_not_starts_with: String
  reason_ends_with: String
  reason_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  AND: [ReportScalarWhereInput!]
  OR: [ReportScalarWhereInput!]
  NOT: [ReportScalarWhereInput!]
}

type ReportSubscriptionPayload {
  mutation: MutationType!
  node: Report
  updatedFields: [String!]
  previousValues: ReportPreviousValues
}

input ReportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReportWhereInput
  AND: [ReportSubscriptionWhereInput!]
  OR: [ReportSubscriptionWhereInput!]
  NOT: [ReportSubscriptionWhereInput!]
}

input ReportUpdateDataInput {
  reportedUser: UserUpdateOneRequiredInput
  from: UserUpdateOneRequiredInput
  reason: String
  where: RoomUpdateOneRequiredInput
  state: String
}

input ReportUpdateInput {
  reportedUser: UserUpdateOneRequiredInput
  from: UserUpdateOneRequiredInput
  reason: String
  where: RoomUpdateOneRequiredInput
  state: String
}

input ReportUpdateManyDataInput {
  reason: String
  state: String
}

input ReportUpdateManyInput {
  create: [ReportCreateInput!]
  update: [ReportUpdateWithWhereUniqueNestedInput!]
  upsert: [ReportUpsertWithWhereUniqueNestedInput!]
  delete: [ReportWhereUniqueInput!]
  connect: [ReportWhereUniqueInput!]
  set: [ReportWhereUniqueInput!]
  disconnect: [ReportWhereUniqueInput!]
  deleteMany: [ReportScalarWhereInput!]
  updateMany: [ReportUpdateManyWithWhereNestedInput!]
}

input ReportUpdateManyMutationInput {
  reason: String
  state: String
}

input ReportUpdateManyWithWhereNestedInput {
  where: ReportScalarWhereInput!
  data: ReportUpdateManyDataInput!
}

input ReportUpdateWithWhereUniqueNestedInput {
  where: ReportWhereUniqueInput!
  data: ReportUpdateDataInput!
}

input ReportUpsertWithWhereUniqueNestedInput {
  where: ReportWhereUniqueInput!
  update: ReportUpdateDataInput!
  create: ReportCreateInput!
}

input ReportWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reportedUser: UserWhereInput
  from: UserWhereInput
  reason: String
  reason_not: String
  reason_in: [String!]
  reason_not_in: [String!]
  reason_lt: String
  reason_lte: String
  reason_gt: String
  reason_gte: String
  reason_contains: String
  reason_not_contains: String
  reason_starts_with: String
  reason_not_starts_with: String
  reason_ends_with: String
  reason_not_ends_with: String
  where: RoomWhereInput
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  AND: [ReportWhereInput!]
  OR: [ReportWhereInput!]
  NOT: [ReportWhereInput!]
}

input ReportWhereUniqueInput {
  id: ID
}

type Room {
  roomID: ID!
  Users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  chatting: ChatRoom!
  ready(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  from: Location!
  to: Location!
  when: DateTime!
  roomGenderFilter: Boolean!
  leader: User!
  pay: Payment
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  roomID: ID
  Users: UserCreateManyInput
  chatting: ChatRoomCreateOneInput!
  ready: UserCreateManyInput
  from: LocationCreateOneInput!
  to: LocationCreateOneInput!
  when: DateTime!
  roomGenderFilter: Boolean!
  leader: UserCreateOneInput!
  pay: PaymentCreateOneWithoutConnectedRoomInput
}

input RoomCreateManyInput {
  create: [RoomCreateInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateOneInput {
  create: RoomCreateInput
  connect: RoomWhereUniqueInput
}

input RoomCreateOneWithoutPayInput {
  create: RoomCreateWithoutPayInput
  connect: RoomWhereUniqueInput
}

input RoomCreateWithoutPayInput {
  roomID: ID
  Users: UserCreateManyInput
  chatting: ChatRoomCreateOneInput!
  ready: UserCreateManyInput
  from: LocationCreateOneInput!
  to: LocationCreateOneInput!
  when: DateTime!
  roomGenderFilter: Boolean!
  leader: UserCreateOneInput!
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  roomID_ASC
  roomID_DESC
  when_ASC
  when_DESC
  roomGenderFilter_ASC
  roomGenderFilter_DESC
}

type RoomPreviousValues {
  roomID: ID!
  when: DateTime!
  roomGenderFilter: Boolean!
}

input RoomScalarWhereInput {
  roomID: ID
  roomID_not: ID
  roomID_in: [ID!]
  roomID_not_in: [ID!]
  roomID_lt: ID
  roomID_lte: ID
  roomID_gt: ID
  roomID_gte: ID
  roomID_contains: ID
  roomID_not_contains: ID
  roomID_starts_with: ID
  roomID_not_starts_with: ID
  roomID_ends_with: ID
  roomID_not_ends_with: ID
  when: DateTime
  when_not: DateTime
  when_in: [DateTime!]
  when_not_in: [DateTime!]
  when_lt: DateTime
  when_lte: DateTime
  when_gt: DateTime
  when_gte: DateTime
  roomGenderFilter: Boolean
  roomGenderFilter_not: Boolean
  AND: [RoomScalarWhereInput!]
  OR: [RoomScalarWhereInput!]
  NOT: [RoomScalarWhereInput!]
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

input RoomUpdateDataInput {
  Users: UserUpdateManyInput
  chatting: ChatRoomUpdateOneRequiredInput
  ready: UserUpdateManyInput
  from: LocationUpdateOneRequiredInput
  to: LocationUpdateOneRequiredInput
  when: DateTime
  roomGenderFilter: Boolean
  leader: UserUpdateOneRequiredInput
  pay: PaymentUpdateOneWithoutConnectedRoomInput
}

input RoomUpdateInput {
  Users: UserUpdateManyInput
  chatting: ChatRoomUpdateOneRequiredInput
  ready: UserUpdateManyInput
  from: LocationUpdateOneRequiredInput
  to: LocationUpdateOneRequiredInput
  when: DateTime
  roomGenderFilter: Boolean
  leader: UserUpdateOneRequiredInput
  pay: PaymentUpdateOneWithoutConnectedRoomInput
}

input RoomUpdateManyDataInput {
  when: DateTime
  roomGenderFilter: Boolean
}

input RoomUpdateManyInput {
  create: [RoomCreateInput!]
  update: [RoomUpdateWithWhereUniqueNestedInput!]
  upsert: [RoomUpsertWithWhereUniqueNestedInput!]
  delete: [RoomWhereUniqueInput!]
  connect: [RoomWhereUniqueInput!]
  set: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  deleteMany: [RoomScalarWhereInput!]
  updateMany: [RoomUpdateManyWithWhereNestedInput!]
}

input RoomUpdateManyMutationInput {
  when: DateTime
  roomGenderFilter: Boolean
}

input RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput!
  data: RoomUpdateManyDataInput!
}

input RoomUpdateOneInput {
  create: RoomCreateInput
  update: RoomUpdateDataInput
  upsert: RoomUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: RoomWhereUniqueInput
}

input RoomUpdateOneRequiredInput {
  create: RoomCreateInput
  update: RoomUpdateDataInput
  upsert: RoomUpsertNestedInput
  connect: RoomWhereUniqueInput
}

input RoomUpdateOneRequiredWithoutPayInput {
  create: RoomCreateWithoutPayInput
  update: RoomUpdateWithoutPayDataInput
  upsert: RoomUpsertWithoutPayInput
  connect: RoomWhereUniqueInput
}

input RoomUpdateWithoutPayDataInput {
  Users: UserUpdateManyInput
  chatting: ChatRoomUpdateOneRequiredInput
  ready: UserUpdateManyInput
  from: LocationUpdateOneRequiredInput
  to: LocationUpdateOneRequiredInput
  when: DateTime
  roomGenderFilter: Boolean
  leader: UserUpdateOneRequiredInput
}

input RoomUpdateWithWhereUniqueNestedInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateDataInput!
}

input RoomUpsertNestedInput {
  update: RoomUpdateDataInput!
  create: RoomCreateInput!
}

input RoomUpsertWithoutPayInput {
  update: RoomUpdateWithoutPayDataInput!
  create: RoomCreateWithoutPayInput!
}

input RoomUpsertWithWhereUniqueNestedInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateDataInput!
  create: RoomCreateInput!
}

input RoomWhereInput {
  roomID: ID
  roomID_not: ID
  roomID_in: [ID!]
  roomID_not_in: [ID!]
  roomID_lt: ID
  roomID_lte: ID
  roomID_gt: ID
  roomID_gte: ID
  roomID_contains: ID
  roomID_not_contains: ID
  roomID_starts_with: ID
  roomID_not_starts_with: ID
  roomID_ends_with: ID
  roomID_not_ends_with: ID
  Users_every: UserWhereInput
  Users_some: UserWhereInput
  Users_none: UserWhereInput
  chatting: ChatRoomWhereInput
  ready_every: UserWhereInput
  ready_some: UserWhereInput
  ready_none: UserWhereInput
  from: LocationWhereInput
  to: LocationWhereInput
  when: DateTime
  when_not: DateTime
  when_in: [DateTime!]
  when_not_in: [DateTime!]
  when_lt: DateTime
  when_lte: DateTime
  when_gt: DateTime
  when_gte: DateTime
  roomGenderFilter: Boolean
  roomGenderFilter_not: Boolean
  leader: UserWhereInput
  pay: PaymentWhereInput
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  roomID: ID
}

type Subscription {
  account(where: AccountSubscriptionWhereInput): AccountSubscriptionPayload
  blockedUser(where: BlockedUserSubscriptionWhereInput): BlockedUserSubscriptionPayload
  chatRoom(where: ChatRoomSubscriptionWhereInput): ChatRoomSubscriptionPayload
  deactivate(where: DeactivateSubscriptionWhereInput): DeactivateSubscriptionPayload
  file(where: FileSubscriptionWhereInput): FileSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  message(where: MessageSubscriptionWhereInput): MessageSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  report(where: ReportSubscriptionWhereInput): ReportSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  phoneNumber: String!
  userID: String!
  email: String!
  password: String!
  profilePic: File
  name: String!
  gender: String!
  state: String!
  school: String!
  accountInfo: Account!
  major: String
  studentNum: String
  currentRoom: Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  ReportHistory(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report!]
  Blocking(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  Blocked(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  phoneNumber: String!
  userID: String!
  email: String!
  password: String!
  profilePic: FileCreateOneInput
  name: String!
  gender: String!
  state: String
  school: String!
  accountInfo: AccountCreateOneInput!
  major: String
  studentNum: String
  currentRoom: RoomCreateOneInput
  rooms: RoomCreateManyInput
  ReportHistory: ReportCreateManyInput
  Blocking: UserCreateManyWithoutBlockedInput
  Blocked: UserCreateManyWithoutBlockingInput
}

input UserCreateManyInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutBlockedInput {
  create: [UserCreateWithoutBlockedInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutBlockingInput {
  create: [UserCreateWithoutBlockingInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutBlockedInput {
  id: ID
  phoneNumber: String!
  userID: String!
  email: String!
  password: String!
  profilePic: FileCreateOneInput
  name: String!
  gender: String!
  state: String
  school: String!
  accountInfo: AccountCreateOneInput!
  major: String
  studentNum: String
  currentRoom: RoomCreateOneInput
  rooms: RoomCreateManyInput
  ReportHistory: ReportCreateManyInput
  Blocking: UserCreateManyWithoutBlockedInput
}

input UserCreateWithoutBlockingInput {
  id: ID
  phoneNumber: String!
  userID: String!
  email: String!
  password: String!
  profilePic: FileCreateOneInput
  name: String!
  gender: String!
  state: String
  school: String!
  accountInfo: AccountCreateOneInput!
  major: String
  studentNum: String
  currentRoom: RoomCreateOneInput
  rooms: RoomCreateManyInput
  ReportHistory: ReportCreateManyInput
  Blocked: UserCreateManyWithoutBlockingInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  userID_ASC
  userID_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  gender_ASC
  gender_DESC
  state_ASC
  state_DESC
  school_ASC
  school_DESC
  major_ASC
  major_DESC
  studentNum_ASC
  studentNum_DESC
}

type UserPreviousValues {
  id: ID!
  phoneNumber: String!
  userID: String!
  email: String!
  password: String!
  name: String!
  gender: String!
  state: String!
  school: String!
  major: String
  studentNum: String
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  userID: String
  userID_not: String
  userID_in: [String!]
  userID_not_in: [String!]
  userID_lt: String
  userID_lte: String
  userID_gt: String
  userID_gte: String
  userID_contains: String
  userID_not_contains: String
  userID_starts_with: String
  userID_not_starts_with: String
  userID_ends_with: String
  userID_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  school: String
  school_not: String
  school_in: [String!]
  school_not_in: [String!]
  school_lt: String
  school_lte: String
  school_gt: String
  school_gte: String
  school_contains: String
  school_not_contains: String
  school_starts_with: String
  school_not_starts_with: String
  school_ends_with: String
  school_not_ends_with: String
  major: String
  major_not: String
  major_in: [String!]
  major_not_in: [String!]
  major_lt: String
  major_lte: String
  major_gt: String
  major_gte: String
  major_contains: String
  major_not_contains: String
  major_starts_with: String
  major_not_starts_with: String
  major_ends_with: String
  major_not_ends_with: String
  studentNum: String
  studentNum_not: String
  studentNum_in: [String!]
  studentNum_not_in: [String!]
  studentNum_lt: String
  studentNum_lte: String
  studentNum_gt: String
  studentNum_gte: String
  studentNum_contains: String
  studentNum_not_contains: String
  studentNum_starts_with: String
  studentNum_not_starts_with: String
  studentNum_ends_with: String
  studentNum_not_ends_with: String
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  phoneNumber: String
  userID: String
  email: String
  password: String
  profilePic: FileUpdateOneInput
  name: String
  gender: String
  state: String
  school: String
  accountInfo: AccountUpdateOneRequiredInput
  major: String
  studentNum: String
  currentRoom: RoomUpdateOneInput
  rooms: RoomUpdateManyInput
  ReportHistory: ReportUpdateManyInput
  Blocking: UserUpdateManyWithoutBlockedInput
  Blocked: UserUpdateManyWithoutBlockingInput
}

input UserUpdateInput {
  phoneNumber: String
  userID: String
  email: String
  password: String
  profilePic: FileUpdateOneInput
  name: String
  gender: String
  state: String
  school: String
  accountInfo: AccountUpdateOneRequiredInput
  major: String
  studentNum: String
  currentRoom: RoomUpdateOneInput
  rooms: RoomUpdateManyInput
  ReportHistory: ReportUpdateManyInput
  Blocking: UserUpdateManyWithoutBlockedInput
  Blocked: UserUpdateManyWithoutBlockingInput
}

input UserUpdateManyDataInput {
  phoneNumber: String
  userID: String
  email: String
  password: String
  name: String
  gender: String
  state: String
  school: String
  major: String
  studentNum: String
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
  update: [UserUpdateWithWhereUniqueNestedInput!]
  upsert: [UserUpsertWithWhereUniqueNestedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyMutationInput {
  phoneNumber: String
  userID: String
  email: String
  password: String
  name: String
  gender: String
  state: String
  school: String
  major: String
  studentNum: String
}

input UserUpdateManyWithoutBlockedInput {
  create: [UserCreateWithoutBlockedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutBlockedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutBlockedInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutBlockingInput {
  create: [UserCreateWithoutBlockingInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutBlockingInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutBlockingInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutBlockedDataInput {
  phoneNumber: String
  userID: String
  email: String
  password: String
  profilePic: FileUpdateOneInput
  name: String
  gender: String
  state: String
  school: String
  accountInfo: AccountUpdateOneRequiredInput
  major: String
  studentNum: String
  currentRoom: RoomUpdateOneInput
  rooms: RoomUpdateManyInput
  ReportHistory: ReportUpdateManyInput
  Blocking: UserUpdateManyWithoutBlockedInput
}

input UserUpdateWithoutBlockingDataInput {
  phoneNumber: String
  userID: String
  email: String
  password: String
  profilePic: FileUpdateOneInput
  name: String
  gender: String
  state: String
  school: String
  accountInfo: AccountUpdateOneRequiredInput
  major: String
  studentNum: String
  currentRoom: RoomUpdateOneInput
  rooms: RoomUpdateManyInput
  ReportHistory: ReportUpdateManyInput
  Blocked: UserUpdateManyWithoutBlockingInput
}

input UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpdateWithWhereUniqueWithoutBlockedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutBlockedDataInput!
}

input UserUpdateWithWhereUniqueWithoutBlockingInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutBlockingDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutBlockedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutBlockedDataInput!
  create: UserCreateWithoutBlockedInput!
}

input UserUpsertWithWhereUniqueWithoutBlockingInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutBlockingDataInput!
  create: UserCreateWithoutBlockingInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  userID: String
  userID_not: String
  userID_in: [String!]
  userID_not_in: [String!]
  userID_lt: String
  userID_lte: String
  userID_gt: String
  userID_gte: String
  userID_contains: String
  userID_not_contains: String
  userID_starts_with: String
  userID_not_starts_with: String
  userID_ends_with: String
  userID_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  profilePic: FileWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  school: String
  school_not: String
  school_in: [String!]
  school_not_in: [String!]
  school_lt: String
  school_lte: String
  school_gt: String
  school_gte: String
  school_contains: String
  school_not_contains: String
  school_starts_with: String
  school_not_starts_with: String
  school_ends_with: String
  school_not_ends_with: String
  accountInfo: AccountWhereInput
  major: String
  major_not: String
  major_in: [String!]
  major_not_in: [String!]
  major_lt: String
  major_lte: String
  major_gt: String
  major_gte: String
  major_contains: String
  major_not_contains: String
  major_starts_with: String
  major_not_starts_with: String
  major_ends_with: String
  major_not_ends_with: String
  studentNum: String
  studentNum_not: String
  studentNum_in: [String!]
  studentNum_not_in: [String!]
  studentNum_lt: String
  studentNum_lte: String
  studentNum_gt: String
  studentNum_gte: String
  studentNum_contains: String
  studentNum_not_contains: String
  studentNum_starts_with: String
  studentNum_not_starts_with: String
  studentNum_ends_with: String
  studentNum_not_ends_with: String
  currentRoom: RoomWhereInput
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
  ReportHistory_every: ReportWhereInput
  ReportHistory_some: ReportWhereInput
  ReportHistory_none: ReportWhereInput
  Blocking_every: UserWhereInput
  Blocking_some: UserWhereInput
  Blocking_none: UserWhereInput
  Blocked_every: UserWhereInput
  Blocked_some: UserWhereInput
  Blocked_none: UserWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  phoneNumber: String
  userID: String
  email: String
}
`
      }
    